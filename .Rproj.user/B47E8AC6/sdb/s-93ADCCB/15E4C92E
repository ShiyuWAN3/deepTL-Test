{
    "collab_server" : "",
    "contents" : "ensemble_dnnet <- function(object,\n                           n.ensemble = 100,\n                           esCtrl,\n                           unbalance.trt = c(\"None\", \"Over\", \"Under\", \"Balance\")[1],\n                           prop.keep = 1,\n                           best.opti = TRUE,\n                           min.keep = 10) {\n\n  OOB.error <- list()\n  model.list <- list()\n  model.type <- ifelse(class(object@y) == \"factor\", \"Binary\", \"Continuous\")\n  pred.table <- matrix(NA, n.ensemble, length(object@y))\n  loss <- numeric(length(n.ensemble))\n  keep <- rep(TRUE, n.ensemble)\n  min.keep <- max(min(min.keep, n.ensemble), 1)\n\n  pb <- utils::txtProgressBar(min = 0, max = n.ensemble, style = 3)\n  for(i in 1:n.ensemble) {\n\n    if(class(object) != \"RegObj\" && unbalance.trt != \"None\") {\n\n      y.table <- table(object@y)\n      class.size <- ifelse(unbalance.trt == \"Over\", max(y.table),\n                           ifelse(unbalance.trt == \"Under\", min(y.table),\n                                  ifelse(unbalance.trt == \"Balance\", mean(y.table), stop(\"Invalid input for Unbalance Treatment. \"))))\n      train.ind2 <- c()\n      for(k in 1:length(unique(object@y)))\n        train.ind2 <- c(train.ind2, sample(which(object@y == names(y.table)[k]), class.size, replace = TRUE))\n\n      train.boot <- splitDnnet(object, train.ind2)\n    } else\n      train.boot <- splitDnnet(object, \"bootstrap\")\n\n    trainObj <- train.boot$train\n    validObj <- train.boot$valid\n    trainObj.ind <- train.boot$split\n    args <- esCtrl # removeArg(esCtrl, \"machine\")\n    args <- appendArg(args, \"validate\", validObj, 1)\n    args <- appendArg(args, \"train\", trainObj, 1)\n\n    model <- do.call(deepTL::dnnet, args)\n    model.list[[i]] <- model\n\n    pred <- predict(model, object@x, cutoff = cutoff)\n    if(model.type == \"Continuous\") {\n\n      pred.table[i, ] <- pred\n      loss[i] <- sum(((validObj@y - mean(validObj@y))**2 - (validObj@y - pred[-trainObj.ind])**2) *\n                       validObj@w) / sum(validObj@w)\n\n    } else {\n\n      pred.table[i, ] <- pred[, levels(validObj@y)[1]]\n      loss[i] <- sum((-log(mean(validObj@y == levels(validObj@y)[1])) * (validObj@y == levels(validObj@y)[1]) -\n                        log(1-mean(validObj@y == levels(validObj@y)[1])) * (1-(validObj@y == levels(validObj@y)[1])) +\n                        log(pred[-trainObj.ind, levels(validObj@y)[1]]) * (validObj@y == levels(validObj@y)[1]) +\n                        log(1-pred[-trainObj.ind, levels(validObj@y)[1]]) * (1-(validObj@y == levels(validObj@y)[1]))) *\n                       validObj@w) / sum((validObj@w))\n    }\n\n    utils::setTxtProgressBar(pb, i)\n  }\n  close(pb)\n\n  if(best.opti && model.type == \"Continuous\") {\n\n    mse <- numeric(n.ensemble - 1)\n    for(i in 1:length(mse))\n      mse[i] <- min(sum((object@y - colMeans(pred.table[loss >= sort(loss)[i], ]))**2 *\n                          object@w) / sum(object@w), Inf)\n\n    keep <- loss >= sort(loss)[which.min(mse[1:(n.ensemble - min.keep + 1)])]\n  } else if(best.opti && model.type == \"Binary\") {\n\n    mse <- numeric(n.ensemble - 1)\n    for(i in 1:length(mse))\n      mse[i] <- min(-sum((object@y == levels(validObj@y)[1]) * log(colMeans(pred.table[loss >= sort(loss)[i], ])) +\n                           (1-(object@y == levels(validObj@y)[1])) * log(1-colMeans(pred.table[loss >= sort(loss)[i], ])) *\n                           object@w) / sum(object@w), Inf)\n\n    keep <- loss >= sort(loss)[which.min(mse[1:(n.ensemble - min.keep + 1)])]\n  }\n\n  if(prop.keep[1] < 1)\n    keep <- loss >= sort(loss)[min(max(floor(n.ensemble*(1-prop.keep[1])), 1), n.ensemble - min.keep + 1)]\n  if(length(prop.keep) > 1)\n    for(i in 2:length(prop.keep))\n      keep <- rbind(keep, loss >= sort(loss)[min(max(floor(n.ensemble*(1-prop.keep[i])), 1), n.ensemble - min.keep + 1)])\n\n  return(methods::new(\"dnnetEnsemble\",\n                      model.list = model.list,\n                      model.type = model.type,\n                      loss = loss,\n                      keep = keep))\n}\n",
    "created" : 1538883026847.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2711287303",
    "id" : "15E4C92E",
    "lastKnownWriteTime" : 1538868954,
    "last_content_update" : 1538868954,
    "path" : "~/Dropbox (UFL)/Rpackages/deepTL/deepTL/R/2-3-ensemble.R",
    "project_path" : "R/2-3-ensemble.R",
    "properties" : {
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}